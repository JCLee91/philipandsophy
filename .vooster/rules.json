{
  "rules": [
    {
      "type": "prd",
      "content": "# 필립앤소피 멤버 전용 단방향 채팅방 PRD\n\n## 1. 배경\n필립앤소피는 2주간 온라인 독서 프로그램을 운영한다. 현재 공지·설문·링크가 슬랙 등 여러 채널에 분산돼 참가자가 놓치는 문제가 발생한다. 또한 참가자는 복잡한 가입 절차로 진입 장벽을 느낀다.\n\n## 2. 문제 정의\n1. 운영자의 중요 공지가 잡담에 묻혀 확인이 어렵다.\n2. 공지를 찾는 과정이 번거로워 설문·독서 인증 완료율이 낮다.\n3. 참가자 가입·로그인 절차가 길어 첫 진입부터 이탈이 생긴다.\n\n## 3. 제품 목표\n• 운영자 공지를 단일 채널에 집중시켜 확인율 90% 이상 달성.\n• 설문·독서 인증 완료율 30% → 70% 이상으로 상승.\n• 4자리 코드 입력만으로 30초 내 첫 접속 완료율 95% 달성.\n\n## 4. 핵심 지표 (Success Metrics)\n1. 공지 열람률\n2. 설문·독서 인증 완료률\n3. 첫 접속 소요 시간\n4. 푸시 알림 클릭률\n\n## 5. 대상 사용자(Target Users)\n• 기수별 20명 내외로 내부 승인된 독서 프로그램 참가자 (모바일 중심 이용)\n\n## 6. 핵심 기능 (Scope)\n1. **운영자 단방향 공지 채팅** – 텍스트·이미지·파일·링크 포함\n2. **4자리 코드 기반 초간단 입장** – 참가자는 코드만 입력 후 바로 접속\n3. **푸시 알림** – 새 공지 시 즉각 푸시 전송 (웹푸시·모바일 대응)\n4. **설문/독서 인증 버튼 바로가기** – 공지 하단 CTA 버튼으로 연결\n\n### Nice-to-Have (MVP 이후)\n• 공지 예약 발송\n• 공지 읽음 여부 통계\n\n## 7. 비범위(Non-Goals)\n• 참가자 간 실시간 대화 기능\n• 복잡한 프로필·커뮤니티 기능\n• 멀티 프로그램 통합 관리\n\n## 8. 사용자 스토리(User Stories)\n1. 참가자는 4자리 코드를 입력해 즉시 채팅방에 입장하고 최신 공지를 본다.\n2. 운영자는 이미지를 포함한 공지를 발행하고, 참가자에게 푸시 알림을 보낸다.\n3. 참가자는 공지 하단 ‘독서 인증하기’ 버튼을 눌러 설문 폼으로 이동한다.\n\n## 9. 기술 및 제약조건\n• 플랫폼: 반응형 웹 (모바일 퍼스트)\n• 스택: Next.js 15, Typescript, TailwindCSS, shadcn, Supabase, React-Query 등 EasyNext 템플릿 기본 스택\n• 데이터 보안: 참가자 인증 코드는 기수별로 별도 발급 및 서버 검증\n\n## 10. 일정\nMVP 목표 4주\nWeek 1  UI 목업 & 4자리 코드 로그인\nWeek 2  공지 입력/출력, 파일‧이미지 업로드\nWeek 3  푸시 알림, 설문 버튼 연결\nWeek 4  QA & 배포, 첫 파일럿 운영\n\n## 11. 이해관계자\n• Product Owner: 필립앤소피 운영팀\n• 개발: CLAUDE_CODE 에이전트 & 프론트 1명\n• 디자인: Brand Designer 1명\n\n## 12. 리스크 및 대응\n• 푸시 알림 브라우저 권한 거부 → 이메일 백업 알림 고려 (MVP 외)\n• 코드 공유로 비승인 사용자가 입장할 가능성 → 기수별 서버 측 화이트리스트 검증\n\n---\n본 PRD는 MVP 범위에서 필수 요소만 정의하였다. 이후 피드백에 따라 단계적 개선을 진행한다.",
      "writedAt": "2025-10-01T02:03:39.543Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n  \n## Tech Stack\n\nNext.js 15, TypeScript, TailwindCSS, shadcn, lucide-react, @tanstack/react-query, date-fns, Vercel, GitHub Actions\n\n## Directory Structure\n\n\n/\n├── src/\n│   ├── app/                    # Next.js app router\n│   ├── components/             # common components\n│   │   └── ui/                 # shadcn/ui components\n│   ├── features/               # custom hooks (handle business logic)\n│   │   └── [featureName]/      # feature-based directory\n│   │   │   └── components/     # feature-based components\n│   │   │   └── hooks/          # feature-based hooks\n│   │   │   └── lib/            # feature-based lib\n│   │   │   └── pages/          # feature-based page components\n│   │   │   └── api.ts          # feature-based api callers\n│   │   │   └── schema.ts       # feature-based api schemas (zod)\n│   │   │   └── constants.ts    # feature-based constants\n│   │   │   └── types.ts        # feature-based types\n│   │   │   └── utils.ts        # feature-based utils\n│   │   └── ...                 # other features\n│   ├── hooks/                  # common hooks\n│   ├── lib/                    \n│   │   └── utils.ts            # shadcn cn utility function\n├── public/                     # static assets\n└── supabase/migrations         # supabase migrations (0000_name.sql)\n\n  ",
      "writedAt": "2025-10-01T02:03:39.543Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-10-01T02:03:39.543Z"
    },
    {
      "type": "design-guide",
      "content": "# 필립앤소피 멤버 전용 단방향 채팅방 Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n\n본 서비스는 **신뢰할 수 있고 전문적인** 분위기를 추구합니다. 독서 프로그램 참가자들이 운영자의 중요한 공지를 놓치지 않고 집중해서 확인할 수 있도록, 산만하지 않은 깔끔하고 정돈된 인터페이스를 제공합니다. \n\n차분한 색상과 넉넉한 여백을 통해 안정감을 주며, 동시에 필요한 정보와 액션 버튼이 명확히 구분되어 사용자가 직관적으로 다음 단계를 수행할 수 있도록 설계되었습니다. 전체적으로 **미니멀하면서도 따뜻한** 느낌을 유지하여 독서라는 활동의 본질에 집중할 수 있는 환경을 조성합니다.\n\n## 2. Reference Service (참조 서비스)\n\n- **Name**: Dropbox Paper\n- **Description**: 협업과 문서 작성에 최적화된 깔끔한 온라인 에디터 서비스\n- **Design Mood**: 넉넉한 여백과 라이트 그레이 배경을 활용한 차분하고 전문적인 분위기\n- **Primary Color**: #0061FF (Dropbox Blue)\n- **Secondary Color**: #00D4AA (Dropbox Teal)\n\nDropbox Paper의 디자인 철학을 참조하여 불필요한 요소를 제거하고 콘텐츠에 집중할 수 있는 환경을 만들었습니다. 특히 깨끗한 헤더 영역과 부드러운 색상 조합을 통해 사용자가 편안하게 정보를 소비할 수 있도록 설계했습니다.\n\n## 3. Color & Gradient (색상 & 그라데이션)\n\n**쿨톤 기반의 저채도 컬러 팔레트**를 사용하여 안정감과 신뢰성을 표현합니다.\n\n- **Primary Color**: #1E2A44 (네이비) - 메인 텍스트, 헤더, 중요 요소\n- **Secondary Color**: #4FA3FF (스카이 블루) - 보조 정보, 링크, 알림 요소  \n- **Accent Color**: #24C7A2 (에메랄드) - CTA 버튼, 강조 포인트\n- **Background Color**: #F5F7FA (라이트 그레이) - 메인 배경\n- **Text Color**: #2A2D34 (차콜) - 본문 텍스트\n- **Border Color**: #E1E5E9 - 구분선, 카드 테두리\n- **Success**: #10B981 - 성공 상태\n- **Warning**: #F59E0B - 주의 상태\n- **Error**: #EF4444 - 오류 상태\n\n**Color Usage**:\n1. **Primary**: 헤더, 네비게이션, 중요 텍스트에 사용\n2. **Secondary**: 부가 정보, 아이콘, 링크 상태에 사용  \n3. **Accent**: 주요 액션 버튼, 완료/성공 상태에 사용\n4. **Background**: 전체 배경, 카드 배경에 사용\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n\n웹 안전 폰트인 **Inter**를 메인으로 사용하여 가독성과 일관성을 확보합니다.\n\n- **Heading 1**: Inter, 32px, Font Weight 600, Line Height 1.2\n- **Heading 2**: Inter, 24px, Font Weight 600, Line Height 1.3  \n- **Heading 3**: Inter, 20px, Font Weight 600, Line Height 1.4\n- **Body Large**: Inter, 16px, Font Weight 400, Line Height 1.5\n- **Body Medium**: Inter, 14px, Font Weight 400, Line Height 1.5\n- **Body Small**: Inter, 12px, Font Weight 400, Line Height 1.4\n- **Button Text**: Inter, 14px, Font Weight 500, Line Height 1.2\n- **Caption**: Inter, 11px, Font Weight 400, Line Height 1.3\n\n**Letter Spacing**: 기본값 유지 (0)\n**Paragraph Spacing**: 16px 기본, 제목과 본문 사이 24px\n\n## 5. Layout & Structure (레이아웃 & 구조)\n\n**모바일 퍼스트** 접근 방식을 채택하여 반응형 그리드 시스템을 구축합니다.\n\n**기본 레이아웃**:\n- **Container Max Width**: 768px (태블릿 이상에서 중앙 정렬)\n- **Side Padding**: 16px (모바일), 24px (태블릿 이상)\n- **Vertical Spacing**: 16px 기본 간격\n- **Section Spacing**: 32px\n\n**그리드 시스템**:\n- **Mobile**: 단일 컬럼, 100% width\n- **Tablet**: 필요시 2컬럼 (8:4 비율)\n- **Desktop**: 메인 콘텐츠 중앙 정렬, 최대 768px\n\n**주요 영역 구성**:\n1. **Header**: 고정 상단바 (56px 높이)\n2. **Main Content**: 스크롤 가능한 공지 리스트 영역\n3. **Footer**: 필요시 고정 하단 액션 영역\n\n## 6. Visual Style (비주얼 스타일)\n\n**미니멀하고 기능적인** 비주얼 스타일을 추구합니다.\n\n**아이콘**:\n- **라이브러리**: Lucide React 사용\n- **스타일**: Stroke 기반, 1.5px 두께\n- **크기**: 16px (Small), 20px (Medium), 24px (Large)\n- **색상**: Primary (#1E2A44) 또는 Secondary (#4FA3FF)\n\n**이미지**:\n- **Border Radius**: 8px (카드 내 이미지), 4px (썸네일)\n- **Aspect Ratio**: 16:9 (가로형), 1:1 (프로필/아이콘)\n- **최대 너비**: 100% (반응형)\n\n**일러스트레이션**:\n- **스타일**: 라인 아트 기반, 미니멀\n- **색상**: Primary와 Accent 색상 조합\n- **용도**: 빈 상태, 온보딩, 오류 페이지\n\n**그림자와 깊이**:\n- **Card Shadow**: 0 2px 8px rgba(0, 0, 0, 0.08)\n- **Button Shadow**: 0 1px 3px rgba(0, 0, 0, 0.12)\n- **Modal Shadow**: 0 8px 32px rgba(0, 0, 0, 0.16)\n\n## 7. UX Guide (UX 가이드)\n\n**타겟 사용자**: 독서 프로그램 참가자 (모바일 중심 사용, 다양한 연령대)\n\n**핵심 UX 원칙**:\n\n1. **단순함 우선**: 4자리 코드 입력만으로 30초 내 접속 완료\n2. **정보 집중**: 단방향 공지로 중요 정보가 묻히지 않도록 설계\n3. **즉시성**: 새 공지 시 푸시 알림으로 즉각 전달\n4. **액션 명확성**: CTA 버튼을 통한 명확한 다음 단계 안내\n\n**사용성 가이드**:\n- **터치 타겟**: 최소 44px × 44px (iOS 가이드라인 준수)\n- **스크롤**: 자동 스크롤로 최신 공지가 항상 보이도록 설정\n- **로딩**: 스켈레톤 UI로 로딩 상태 표시\n- **오류 처리**: 친화적인 오류 메시지와 재시도 옵션 제공\n\n**접근성**:\n- **색상 대비**: WCAG 2.1 AA 기준 이상 (4.5:1)\n- **키보드 네비게이션**: Tab 순서와 Focus 상태 명확히 표시\n- **스크린 리더**: 적절한 aria-label과 semantic HTML 사용\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n\n### 8.1 버튼 (Buttons)\n\n**Primary Button**:\n- 배경색: #24C7A2 (Accent)\n- 텍스트: #FFFFFF, Font Weight 500\n- 높이: 44px, Padding: 12px 24px\n- Border Radius: 22px (Fully Rounded)\n- Hover: 배경색 10% 어두워짐\n\n**Secondary Button**:\n- 배경색: 투명, 테두리: 2px solid #4FA3FF\n- 텍스트: #4FA3FF, Font Weight 500\n- 높이: 44px, Padding: 12px 24px\n- Border Radius: 22px\n\n**Ghost Button**:\n- 배경색: 투명\n- 텍스트: #1E2A44, Font Weight 500\n- 높이: 44px, Padding: 12px 16px\n- Hover: 배경색 #F5F7FA\n\n### 8.2 입력 필드 (Input Fields)\n\n**4자리 코드 입력**:\n- 4개의 개별 입력 칸 (각 48px × 48px)\n- Border: 2px solid #E1E5E9\n- Border Radius: 8px\n- Focus: Border #4FA3FF, Box Shadow\n- 텍스트: 중앙 정렬, 20px, Font Weight 600\n\n**일반 텍스트 입력**:\n- 높이: 44px, Padding: 12px 16px\n- Border: 1px solid #E1E5E9\n- Border Radius: 8px\n- Focus: Border #4FA3FF\n\n### 8.3 카드 (Cards)\n\n**공지 카드**:\n- 배경색: #FFFFFF\n- Border: 1px solid #E1E5E9\n- Border Radius: 12px\n- Padding: 20px\n- Shadow: 0 2px 8px rgba(0, 0, 0, 0.08)\n- Margin Bottom: 16px\n\n**코드 입력 카드**:\n- 배경색: #FFFFFF\n- Border Radius: 16px\n- Padding: 32px 24px\n- Shadow: 0 4px 16px rgba(0, 0, 0, 0.12)\n- 중앙 정렬\n\n### 8.4 네비게이션 (Navigation)\n\n**상단바**:\n- 높이: 56px\n- 배경색: #FFFFFF\n- Border Bottom: 1px solid #E1E5E9\n- Padding: 0 16px\n- 좌측: 로고/프로그램명\n- 우측: 아이콘 버튼들\n\n**네비게이션 아이콘**:\n- 크기: 24px\n- 색상: #1E2A44\n- 터치 영역: 44px × 44px\n- 활성 상태: #4FA3FF\n\n### 8.5 알림 및 피드백 (Notifications & Feedback)\n\n**푸시 권한 배너**:\n- 배경색: #F0F8FF\n- Border: 1px solid #4FA3FF\n- Border Radius: 8px\n- Padding: 16px\n- 닫기 버튼 포함\n\n**토스트 메시지**:\n- 배경색: #1E2A44\n- 텍스트: #FFFFFF\n- Border Radius: 8px\n- Padding: 12px 16px\n- 하단에서 슬라이드 업\n\n**로딩 상태**:\n- 스켈레톤 UI 사용\n- 배경색: #F5F7FA\n- 애니메이션: 부드러운 펄스 효과\n\n### 8.6 모션 및 전환 (Motion & Transitions)\n\n**페이지 전환**:\n- Fade In/Out: 150ms ease-in-out\n- 슬라이드: 200ms ease-out\n\n**버튼 상호작용**:\n- Hover: 100ms ease-out\n- Active: 50ms ease-in\n\n**스크롤 애니메이션**:\n- 새 공지 등장: Slide Up 100ms\n- 자동 스크롤: 300ms ease-out",
      "writedAt": "2025-10-01T02:03:39.543Z"
    },
    {
      "type": "ia",
      "content": "# 필립앤소피 멤버 전용 단방향 채팅방 Information Architecture (IA)\n\n## 1. 사이트맵 (사이트맵)\n\n```\n필립앤소피 채팅방\n├── / (랜딩 페이지)\n│   └── 4자리 코드 입력\n├── /chat (채팅방)\n│   ├── 공지사항 목록\n│   ├── 푸시 알림 설정\n│   └── 설문/독서 인증 링크\n├── /admin (관리자 영역)\n│   ├── /login (관리자 로그인)\n│   ├── /dashboard (관리자 대시보드)\n│   ├── /notices (공지사항 관리)\n│   │   ├── /new (새 공지 작성)\n│   │   └── /[id]/edit (공지 수정)\n│   └── /settings (설정)\n├── /404 (페이지 없음)\n└── /error (오류 페이지)\n```\n\n## 2. 사용자 흐름 (사용자 흐름)\n\n### 주요 작업: 참가자 코드 입장 및 공지 확인\n1. 사용자가 서비스 URL에 접속한다\n2. 랜딩 페이지에서 4자리 참가 코드를 입력한다\n3. \"입장\" 버튼을 클릭한다\n4. 코드 검증 후 채팅방 페이지로 리다이렉트된다\n5. 최신 공지가 자동으로 최상단에 표시된다\n6. 푸시 알림 권한 요청 배너가 나타난다 (최초 1회)\n7. 공지 하단의 \"독서 인증하기\" 버튼을 클릭한다\n8. 외부 설문 폼이 새 창으로 열린다\n9. 설문 완료 후 브라우저 뒤로가기로 채팅방 복귀한다\n\n### 주요 작업: 운영자 공지 발행\n1. 운영자가 /admin/login에서 이메일+비밀번호로 로그인한다\n2. 관리자 대시보드에서 \"새 공지 작성\" 버튼을 클릭한다\n3. 공지 작성 폼에서 제목, 본문, CTA 링크를 입력한다\n4. 이미지나 파일을 첨부한다 (선택사항)\n5. \"즉시 발행\" 버튼을 클릭한다\n6. 공지가 저장되고 참가자들에게 푸시 알림이 발송된다\n7. 관리자는 발행된 공지를 실시간으로 확인한다\n\n### 주요 작업: 푸시 알림을 통한 공지 확인\n1. 참가자가 새 공지 푸시 알림을 받는다\n2. 알림을 터치하여 채팅방으로 직접 이동한다\n3. 해당 공지가 하이라이트되어 표시된다\n4. 공지 내용을 확인하고 필요한 액션을 수행한다\n\n## 3. 네비게이션 구조 (네비게이션 구조)\n\n### 글로벌 네비게이션 (GNB)\n**참가자용 상단바**\n- 좌측: 프로그램명 (필립앤소피 독서모임)\n- 우측: 알림 아이콘 (푸시 설정 재요청용)\n\n**관리자용 상단바**\n- 좌측: 관리자 대시보드 로고\n- 우측: 새 공지 작성 버튼, 로그아웃 버튼\n\n### 로컬 네비게이션 (LNB)\n**관리자 사이드바**\n- 공지사항 관리\n- 참가자 통계 (MVP 이후)\n- 설정\n\n### 푸터\n- 서비스 정보\n- 문의하기 링크\n- 개인정보처리방침\n\n## 4. 페이지 계층 구조 (페이지 계층 구조)\n\n```\n/ (Depth 1)\n/chat (Depth 1)\n/admin (Depth 1)\n  /admin/login (Depth 2)\n  /admin/dashboard (Depth 2)\n  /admin/notices (Depth 2)\n    /admin/notices/new (Depth 3)\n    /admin/notices/[id]/edit (Depth 3)\n  /admin/settings (Depth 2)\n/404 (Depth 1)\n/error (Depth 1)\n```\n\n## 5. 콘텐츠 구성 (콘텐츠 구성)\n\n| 페이지 | 주요 콘텐츠 요소 |\n|---|---|\n| 랜딩 (/) | 서비스 소개 텍스트, 4자리 코드 입력 필드, 입장 버튼, 오류 메시지 영역 |\n| 채팅방 (/chat) | 상단바, 공지사항 카드 리스트, 푸시 알림 권한 배너, 자동 스크롤 |\n| 관리자 로그인 (/admin/login) | 로그인 폼, 이메일 필드, 비밀번호 필드, 로그인 버튼 |\n| 관리자 대시보드 (/admin/dashboard) | 통계 카드, 최근 공지 목록, 새 공지 작성 버튼 |\n| 공지 관리 (/admin/notices) | 공지 목록 테이블, 검색 필터, 새 공지 작성 버튼, 편집/삭제 액션 |\n| 공지 작성 (/admin/notices/new) | 제목 입력, 본문 텍스트에리어, CTA 링크 설정, 파일 업로드, 발행 버튼 |\n\n## 6. 인터랙션 패턴 (인터랙션 패턴)\n\n### 코드 입력 패턴\n- 4개의 개별 입력 칸으로 구성\n- 자동 포커스 이동 (한 칸 입력 완료 시 다음 칸으로)\n- 실시간 유효성 검사\n- 오류 시 전체 필드 하이라이트\n\n### 공지사항 표시 패턴\n- 카드 형태의 공지 레이아웃\n- 최신 공지 자동 스크롤\n- 이미지/파일 첨부 시 미리보기 제공\n- CTA 버튼 하단 고정 배치\n\n### 푸시 알림 패턴\n- 권한 요청 배너 (닫기 가능)\n- 토스트 메시지로 알림 상태 표시\n- 알림 클릭 시 해당 공지로 스크롤\n\n### 관리자 폼 패턴\n- 실시간 미리보기 제공\n- 드래그 앤 드롭 파일 업로드\n- 자동 저장 기능 (임시저장)\n- 발행 전 확인 모달\n\n## 7. URL 구조 (URL 구조)\n\n### 일반 규칙\n- 소문자 사용\n- 하이픈(-) 구분자 사용\n- RESTful 패턴 준수\n\n### URL 매핑\n```\n/ - 랜딩 페이지\n/chat - 채팅방\n/admin/login - 관리자 로그인\n/admin/dashboard - 관리자 대시보드\n/admin/notices - 공지사항 목록\n/admin/notices/new - 새 공지 작성\n/admin/notices/:id/edit - 공지 수정\n/admin/settings - 관리자 설정\n/404 - 페이지 없음\n/error - 오류 페이지\n```\n\n### 쿼리 파라미터\n```\n/chat?highlight=:noticeId - 특정 공지 하이라이트\n/admin/notices?page=:number&search=:keyword - 공지 목록 필터링\n```\n\n## 8. 컴포넌트 계층 구조 (컴포넌트 계층 구조)\n\n### 글로벌 컴포넌트\n- **Header**: 상단 네비게이션 바\n- **Footer**: 하단 정보 영역\n- **Layout**: 페이지 레이아웃 래퍼\n- **LoadingSpinner**: 로딩 상태 표시\n- **Toast**: 알림 메시지\n- **Modal**: 모달 다이얼로그\n\n### 페이지별 컴포넌트\n**랜딩 페이지**\n- CodeInputCard: 4자리 코드 입력 카드\n- CodeInputField: 개별 코드 입력 필드\n- EnterButton: 입장 버튼\n\n**채팅방 페이지**\n- ChatContainer: 채팅 전체 컨테이너\n- NoticeCard: 공지사항 카드\n- NoticeContent: 공지 내용 영역\n- CTAButton: 액션 버튼\n- PushBanner: 푸시 알림 권한 배너\n\n**관리자 페이지**\n- AdminLayout: 관리자 레이아웃\n- NoticeList: 공지 목록 테이블\n- NoticeForm: 공지 작성/수정 폼\n- FileUpload: 파일 업로드 컴포넌트\n- PreviewPanel: 미리보기 패널\n\n### 공통 UI 컴포넌트\n- **Button**: 기본 버튼 (Primary, Secondary, Ghost)\n- **Input**: 텍스트 입력 필드\n- **Textarea**: 긴 텍스트 입력\n- **Card**: 카드 컨테이너\n- **Badge**: 상태 표시 뱃지\n- **Skeleton**: 로딩 스켈레톤 UI\n\n### 데이터 컴포넌트\n- **NoticeProvider**: 공지사항 상태 관리\n- **AuthProvider**: 인증 상태 관리\n- **PushProvider**: 푸시 알림 상태 관리",
      "writedAt": "2025-10-01T02:03:39.543Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-10-01T02:03:39.543Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-10-01T02:03:39.543Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-10-01T02:03:39.543Z"
    }
  ]
}