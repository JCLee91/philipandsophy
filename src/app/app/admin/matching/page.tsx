'use client';

import { Suspense, useState, useEffect, useMemo, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Users, Check, X, Loader2 } from 'lucide-react';
import { getYesterdayString } from '@/lib/date-utils';
import { getDailyQuestionText } from '@/constants/daily-questions';
import { MATCHING_CONFIG } from '@/constants/matching';
import { CARD_STYLES } from '@/constants/ui';
import { logger } from '@/lib/logger';
import { useSession } from '@/hooks/use-session';
import { useYesterdaySubmissionCount } from '@/hooks/use-yesterday-submission-count';
import { useTodaySubmissionCount } from '@/hooks/use-today-submission-count';
import PageTransition from '@/components/PageTransition';
import UnifiedButton from '@/components/UnifiedButton';
import HeaderNavigation from '@/components/HeaderNavigation';
import ParticipantAssignmentTable from '@/components/admin/ParticipantAssignmentTable';
import { useToast } from '@/hooks/use-toast';
import { useParticipantsByCohort } from '@/hooks/use-participants';
import type { Participant } from '@/types/database';
import { appRoutes } from '@/lib/navigation';

interface MatchingReasons {
  similar?: string;
  opposite?: string;
  summary?: string;
}

interface ParticipantAssignment {
  similar: string[];
  opposite: string[];
  reasons?: MatchingReasons | null;
}

interface MatchingResponse {
  success: boolean;
  date: string;
  question?: string;
  totalParticipants?: number;
  matching: {
    featured?: {
      similar: string[];
      opposite: string[];
      reasons?: MatchingReasons | null;
    };
    assignments?: Record<string, ParticipantAssignment>;
  };
  featuredParticipants?: {
    similar: Array<{ id: string; name: string }>;
    opposite: Array<{ id: string; name: string }>;
  };
  submissionStats?: {
    submitted: number;
    notSubmitted: number;
    notSubmittedList: Array<{ id: string; name: string }>;
  };
}

interface AssignmentRow {
  viewerId: string;
  viewerName: string;
  similarTargets: Array<{ id: string; name: string }>;
  oppositeTargets: Array<{ id: string; name: string }>;
  reasons?: MatchingReasons | null;
}

function MatchingPageContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const cohortId = searchParams.get('cohort');
  const { currentUser, isLoading: sessionLoading, sessionToken } = useSession();
  const { toast } = useToast();
  const { data: cohortParticipants = [], isLoading: participantsLoading } = useParticipantsByCohort(cohortId || undefined);

  // Ïã§ÏãúÍ∞Ñ Ï†úÏ∂ú Ïπ¥Ïö¥Ìä∏ (Firebase onSnapshot)
  const { count: yesterdayCount, isLoading: isLoadingYesterday } = useYesterdaySubmissionCount(cohortId || undefined);
  const { count: todayCount, isLoading: isLoadingToday } = useTodaySubmissionCount(cohortId || undefined);

  // Îß§Ïπ≠ ÏÉÅÌÉú Í¥ÄÎ¶¨: idle | previewing | confirmed
  const [matchingState, setMatchingState] = useState<'idle' | 'previewing' | 'confirmed'>('idle');
  const [isProcessing, setIsProcessing] = useState(false);
  const [previewResult, setPreviewResult] = useState<MatchingResponse | null>(null);
  const [confirmedResult, setConfirmedResult] = useState<MatchingResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  // ÎÇ†Ïßú Ï†ïÏùò
  const submissionDate = getYesterdayString(); // Ï†úÏ∂ú ÎÇ†Ïßú (Ïñ¥Ï†ú Îç∞Ïù¥ÌÑ∞, Firebase ÌÇ§Î°ú ÏÇ¨Ïö©)
  const submissionQuestion = getDailyQuestionText(submissionDate);

  // Ïò§Îäò Ï†úÏ∂ú ÌòÑÌô© ÌëúÏãúÏö© (UI Ï†ÑÏö©)
  const todayDate = new Date().toISOString().split('T')[0]; // Ïò§Îäò ÎÇ†Ïßú
  const todayQuestion = getDailyQuestionText(todayDate);

  // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÌÇ§ (submissionDate Í∏∞Ï§Ä)
  const PREVIEW_STORAGE_KEY = `matching-preview-${cohortId}-${submissionDate}`;
  const CONFIRMED_STORAGE_KEY = `matching-confirmed-${cohortId}-${submissionDate}`;
  const IN_PROGRESS_KEY = `matching-in-progress-${cohortId}-${submissionDate}`;

  // localStorage Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Î∞è ÏïàÏ†ÑÌïú Î°úÎìú
  const STORAGE_VERSION = '1.0';
  const STORAGE_TTL = 24 * 60 * 60 * 1000; // 24ÏãúÍ∞Ñ

  const loadFromStorage = (key: string): MatchingResponse | null => {
    try {
      const stored = localStorage.getItem(key);
      if (!stored) return null;

      const parsed = JSON.parse(stored);

      // Î≤ÑÏ†Ñ Ï≤¥ÌÅ¨
      if (parsed.version && parsed.version !== STORAGE_VERSION) {
        logger.warn('Outdated localStorage schema, clearing', { key });
        localStorage.removeItem(key);
        return null;
      }

      // TTL Ï≤¥ÌÅ¨ (ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÍ∞Ä ÏûàÎäî Í≤ΩÏö∞)
      if (parsed.timestamp && Date.now() - parsed.timestamp > STORAGE_TTL) {
        logger.warn('Expired localStorage data, clearing', { key });
        localStorage.removeItem(key);
        return null;
      }

      // Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ Í≤ÄÏ¶ù (data ÌïÑÎìú ÎòêÎäî ÏßÅÏ†ë MatchingResponse ÌòïÌÉú)
      const data = parsed.data || parsed;
      if (!data.matching || !data.date) {
        logger.error('Invalid localStorage data structure', { key });
        localStorage.removeItem(key);
        return null;
      }

      return data;
    } catch (error) {
      logger.error('localStorage parsing error', { key, error });
      // ÏÜêÏÉÅÎêú Îç∞Ïù¥ÌÑ∞ Ï†úÍ±∞
      try {
        localStorage.removeItem(key);
      } catch (e) {
        // Ignore removal errors
      }
      return null;
    }
  };

  const saveToStorage = (key: string, data: MatchingResponse) => {
    try {
      const stored = {
        version: STORAGE_VERSION,
        timestamp: Date.now(),
        data,
      };
      localStorage.setItem(key, JSON.stringify(stored));
    } catch (error) {
      logger.error('localStorage save error', { key, error });
    }
  };

  // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú ÏûêÎèô ÏÉùÏÑ±Îêú preview ÎòêÎäî Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Î≥µÏõê
  useEffect(() => {
    if (typeof window === 'undefined' || !cohortId) return;

    const loadPreview = async () => {
      try {
        // 1. Ï§ëÎã®Îêú Îß§Ïπ≠ ÏûëÏóÖ Í∞êÏßÄ
        const interruptedJob = localStorage.getItem(IN_PROGRESS_KEY);
        if (interruptedJob) {
          const timestamp = parseInt(interruptedJob, 10);
          const elapsedMinutes = Math.floor((Date.now() - timestamp) / 1000 / 60);

          toast({
            title: 'Ï§ëÎã®Îêú Îß§Ïπ≠ ÏûëÏóÖ Í∞êÏßÄ',
            description: `${elapsedMinutes}Î∂Ñ Ï†Ñ ÏãúÏûëÎêú Îß§Ïπ≠Ïù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌïòÏãúÍ≤†ÏäµÎãàÍπå?`,
            variant: 'default',
          });

          // ÌîåÎûòÍ∑∏ Ï†úÍ±∞ (Ìïú Î≤àÎßå ÏïåÎ¶º)
          localStorage.removeItem(IN_PROGRESS_KEY);
          logger.warn('Ï§ëÎã®Îêú Îß§Ïπ≠ ÏûëÏóÖ Í∞êÏßÄ', { timestamp, elapsedMinutes });
        }

        // 2. FirestoreÏóêÏÑú ÏûêÎèô ÏÉùÏÑ±Îêú preview Ï°∞Ìöå (scheduled functionÏù¥ ÏÉùÏÑ±Ìïú Í≤É)
        const { getDb } = await import('@/lib/firebase');
        const { collection, query, where, getDocs, orderBy, limit } = await import('firebase/firestore');

        const db = getDb();
        const previewsRef = collection(db, 'matching_previews');
        const q = query(
          previewsRef,
          where('cohortId', '==', cohortId),
          where('status', '==', 'pending'),
          orderBy('createdAt', 'desc'),
          limit(1)
        );

        const snapshot = await getDocs(q);

        if (!snapshot.empty) {
          // ÏûêÎèô ÏÉùÏÑ±Îêú preview Î∞úÍ≤¨!
          const doc = snapshot.docs[0];
          const data = doc.data();

          const autoGeneratedPreview: MatchingResponse = {
            success: true,
            date: data.date,
            question: data.question,
            totalParticipants: data.totalParticipants,
            matching: data.matching,
            featuredParticipants: data.featuredParticipants,
            submissionStats: data.submissionStats,
          };

          setPreviewResult(autoGeneratedPreview);
          setMatchingState('previewing');

          // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÎèÑ Ï†ÄÏû• (ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ® ÎåÄÎπÑ)
          saveToStorage(PREVIEW_STORAGE_KEY, autoGeneratedPreview);

          logger.info('ü§ñ ÏûêÎèô ÏÉùÏÑ±Îêú Îß§Ïπ≠ ÌîÑÎ¶¨Î∑∞ Î°úÎìú ÏôÑÎ£å', {
            date: data.date,
            docId: doc.id,
            autoGenerated: true
          });

          toast({
            title: 'ü§ñ ÏûêÎèô Î∂ÑÏÑù ÏôÑÎ£å',
            description: `AIÍ∞Ä ${data.totalParticipants}Î™ÖÏùò ÎãµÎ≥ÄÏùÑ Î∂ÑÏÑùÌñàÏñ¥Ïöî!`,
          });

          return; // ÏûêÎèô ÏÉùÏÑ±Îêú previewÎ•º Ï∞æÏïòÏúºÎØÄÎ°ú Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï≤¥ÌÅ¨ ÏÉùÎûµ
        }

        // 3. FirestoreÏóê ÏóÜÏúºÎ©¥ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Î≥µÏõê
        const savedPreview = loadFromStorage(PREVIEW_STORAGE_KEY);
        if (savedPreview) {
          setPreviewResult(savedPreview);
          setMatchingState('previewing');
          logger.info('ÌîÑÎ¶¨Î∑∞ Í≤∞Í≥º Î≥µÏõê ÏôÑÎ£å (Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ)', { date: submissionDate });
        }

        // ‚ö†Ô∏è ÌôïÏ†ï Í≤∞Í≥ºÎäî ÏÑúÎ≤ÑÏóêÏÑú Í∞ÄÏ†∏Ïò§ÎØÄÎ°ú Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Î≥µÏõê Ï†úÍ±∞
        // fetchMatchingResult()Í∞Ä ÏÑúÎ≤ÑÏùò ÏµúÏã† confirmed Í≤∞Í≥ºÎ•º Í∞ÄÏ†∏Ïò¥
      } catch (error) {
        logger.error('ÌîÑÎ¶¨Î∑∞ Î°úÎìú Ïã§Ìå®', error);

        // Firestore Ï°∞Ìöå Ïã§Ìå® ÏãúÏóêÎèÑ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ fallback ÏãúÎèÑ
        const fallbackPreview = loadFromStorage(PREVIEW_STORAGE_KEY);
        if (fallbackPreview) {
          setPreviewResult(fallbackPreview);
          setMatchingState('previewing');
          logger.info('ÌîÑÎ¶¨Î∑∞ Í≤∞Í≥º Î≥µÏõê ÏôÑÎ£å (fallback)', { date: submissionDate });
        }
      }
    };

    loadPreview();
  }, [cohortId, submissionDate, PREVIEW_STORAGE_KEY, IN_PROGRESS_KEY, toast]);

  // beforeunload Í≤ΩÍ≥†: AI Îß§Ïπ≠ Ï≤òÎ¶¨ Ï§ë ÌéòÏù¥ÏßÄ Ïù¥ÌÉà Î∞©ÏßÄ
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (isProcessing) {
        e.preventDefault();
        e.returnValue = ''; // Î∏åÎùºÏö∞Ï†Ä Í∏∞Î≥∏ Í≤ΩÍ≥† Î©îÏãúÏßÄ ÌëúÏãú
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [isProcessing]);

  const participantsById = useMemo(() => {
    const map = new Map<string, Participant>();
    cohortParticipants.forEach((participant) => {
      map.set(participant.id, participant);
    });
    return map;
  }, [cohortParticipants]);

  const assignmentRows = useMemo<AssignmentRow[]>(() => {
    // ÌîÑÎ¶¨Î∑∞ ÎòêÎäî ÌôïÏù∏Îêú Í≤∞Í≥º Ï§ë ÌïòÎÇò ÏÇ¨Ïö©
    const currentResult = previewResult || confirmedResult;
    if (!currentResult?.matching.assignments) return [];

    return cohortParticipants
      .filter((participant) => {
        // Í¥ÄÎ¶¨Ïûê Ï†úÏô∏
        if (participant.isAdmin || participant.isAdministrator) return false;

        // Îß§Ïπ≠ Í≤∞Í≥ºÍ∞Ä ÏûàÎäî Ï∞∏Í∞ÄÏûêÎßå Ìè¨Ìï® (Ïñ¥Ï†ú Ï†úÏ∂úÌïú ÏÇ¨ÎûåÎßå)
        const assignment = currentResult.matching.assignments?.[participant.id];
        return assignment && (assignment.similar?.length > 0 || assignment.opposite?.length > 0);
      })
      .map((participant) => {
        const assignment = currentResult.matching.assignments?.[participant.id];
        const similarTargets = assignment?.similar ?? [];
        const oppositeTargets = assignment?.opposite ?? [];

        // ÏÇ≠Ï†úÎêú Ï∞∏Í∞ÄÏûê ID Í∞êÏßÄ Î∞è Î°úÍπÖ
        const invalidSimilarIds = similarTargets.filter(id => !participantsById.has(id));
        const invalidOppositeIds = oppositeTargets.filter(id => !participantsById.has(id));
        if (invalidSimilarIds.length > 0 || invalidOppositeIds.length > 0) {
          logger.warn('Îß§Ïπ≠ Í≤∞Í≥ºÏóê Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ï∞∏Í∞ÄÏûê ID Î∞úÍ≤¨', {
            viewerId: participant.id,
            viewerName: participant.name,
            invalidSimilarIds,
            invalidOppositeIds,
          });
        }

        return {
          viewerId: participant.id,
          viewerName: participant.name,
          similarTargets: similarTargets
            .filter((id) => participantsById.has(id))
            .map((id) => {
              const target = participantsById.get(id)!;
              return {
                id,
                name: target.name,
              };
            }),
          oppositeTargets: oppositeTargets
            .filter((id) => participantsById.has(id))
            .map((id) => {
              const target = participantsById.get(id)!;
              return {
                id,
                name: target.name,
              };
            }),
          reasons: assignment?.reasons ?? null,
        };
      });
  }, [previewResult, confirmedResult, cohortParticipants, participantsById]);

  // Í∂åÌïú Ï≤¥ÌÅ¨
  useEffect(() => {
    if (!sessionLoading) {
      if (!currentUser) {
        router.replace('/app');
        return;
      }
      // üîí isAdmin + isAdministrator Ïù¥Ï§ë Ï≤¥ÌÅ¨ (ÌïÑÎìúÎ™Ö Ìò∏ÌôòÏÑ±)
      if (!currentUser.isAdmin && !currentUser.isAdministrator) {
        toast({
          title: 'Ï†ëÍ∑º Í∂åÌïú ÏóÜÏùå',
          description: 'Í¥ÄÎ¶¨ÏûêÎßå Ï†ëÍ∑ºÌï† Ïàò ÏûàÎäî ÌéòÏù¥ÏßÄÏûÖÎãàÎã§.',
          variant: 'destructive',
        });
        router.replace(`/app/chat?cohort=${cohortId}`);
        return;
      }
      if (!cohortId) {
        router.replace('/app');
        return;
      }
    }
  }, [sessionLoading, currentUser, cohortId, router, toast]);

  // Í∏∞Ï°¥ Îß§Ïπ≠ Í≤∞Í≥º Î°úÎìú (submissionDate Í∏∞Ï§Ä)
  const fetchMatchingResult = useCallback(async () => {
    if (!cohortId || !sessionToken) return;
    try {
      const response = await fetch(
        `/api/admin/matching?cohortId=${cohortId}&date=${submissionDate}`,
        {
          headers: {
            'Authorization': `Bearer ${sessionToken}`,
          },
        }
      );

      // ‚ÑπÔ∏è 404Îäî Ï†ïÏÉÅ ÏùëÎãµ - ÏïÑÏßÅ Îß§Ïπ≠ÏùÑ Ïã§ÌñâÌïòÏßÄ ÏïäÏïòÏùÑ Îïå
      // Î∏åÎùºÏö∞Ï†Ä ÏΩòÏÜîÏùò 404 ÏóêÎü¨Îäî Î¨¥ÏãúÌï¥ÎèÑ Îê©ÎãàÎã§
      if (response.ok) {
        const data = await response.json();
        setConfirmedResult(data);
        setMatchingState('confirmed');
      }
    } catch (error) {
      logger.error('Îß§Ïπ≠ Í≤∞Í≥º Î°úÎìú Ïã§Ìå®', error);
    }
  }, [cohortId, submissionDate, sessionToken]);

  useEffect(() => {
    if (cohortId) {
      fetchMatchingResult();
    }
  }, [cohortId, fetchMatchingResult]);

  const handleOpenProfile = (participantId: string, theme: 'similar' | 'opposite') => {
    if (!cohortId) return;
    // Ï†úÏ∂ú ÎÇ†Ïßú(Ïñ¥Ï†ú)Î•º URLÏóê Ìè¨Ìï®ÌïòÏó¨ Ïä§Ìè¨ÏùºÎü¨ Î∞©ÏßÄ (Ïò§Îäò Ï†úÏ∂úÎ∂ÑÏùÄ ÏïÑÏßÅ Ïïà Î≥¥Ïù¥ÎèÑÎ°ù)
    const profileUrl = `${appRoutes.profile(participantId, cohortId, theme)}&submissionDate=${encodeURIComponent(submissionDate)}`;
    router.push(profileUrl);
  };

  // 1Îã®Í≥Ñ: AI Îß§Ïπ≠ ÌîÑÎ¶¨Î∑∞ (Ï†ÄÏû•ÌïòÏßÄ ÏïäÏùå)
  const handleStartMatching = async () => {
    // Race condition Î∞©ÏßÄ: Ïù¥ÎØ∏ Ï≤òÎ¶¨Ï§ëÏù¥Î©¥ Ï§ëÎ≥µ Ïã§Ìñâ Ï∞®Îã®
    if (isProcessing) return;

    if (!cohortId || !sessionToken) return;

    setIsProcessing(true);
    setError(null);

    // Ï§ëÎã® Í∞êÏßÄÏö© ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (AI Ï≤òÎ¶¨ ÏãúÏûë ÏãúÏ†ê Í∏∞Î°ù)
    try {
      localStorage.setItem(IN_PROGRESS_KEY, Date.now().toString());
      logger.info('Îß§Ïπ≠ ÏûëÏóÖ ÏãúÏûë ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï', { submissionDate });
    } catch (storageError) {
      logger.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï Ïã§Ìå®', storageError);
    }

    try {
      const response = await fetch('/api/admin/matching/preview', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${sessionToken}`,
        },
        body: JSON.stringify({ cohortId }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || data.error || 'Îß§Ïπ≠ Ïã§Ìñâ Ïã§Ìå®');
      }

      setPreviewResult(data);
      setMatchingState('previewing');

      // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê ÌîÑÎ¶¨Î∑∞ Í≤∞Í≥º Ï†ÄÏû•
      try {
        saveToStorage(PREVIEW_STORAGE_KEY, data);
        logger.info('ÌîÑÎ¶¨Î∑∞ Í≤∞Í≥º Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû• ÏôÑÎ£å', { submissionDate });
      } catch (storageError) {
        logger.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû• Ïã§Ìå®', storageError);
      }

      const matchedCount =
        data.totalParticipants ??
        (data.matching?.assignments
          ? Object.keys(data.matching.assignments).length
          : 0);

      toast({
        title: 'AI Îß§Ïπ≠ ÏôÑÎ£å',
        description: `${matchedCount}Î™ÖÏùò Ï∞∏Í∞ÄÏûê Îß§Ïπ≠ Í≤∞Í≥ºÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.`,
      });

      // ÏÑ±Í≥µ Ïãú Ï§ëÎã® ÌîåÎûòÍ∑∏ Ï†úÍ±∞
      try {
        localStorage.removeItem(IN_PROGRESS_KEY);
        logger.info('Îß§Ïπ≠ ÏûëÏóÖ ÏôÑÎ£å, ÌîåÎûòÍ∑∏ Ï†úÍ±∞', { submissionDate });
      } catch (storageError) {
        logger.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÌîåÎûòÍ∑∏ Ï†úÍ±∞ Ïã§Ìå®', storageError);
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Îß§Ïπ≠ Ïã§Ìñâ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
      setError(errorMessage);
      toast({
        title: 'Îß§Ïπ≠ Ïã§Ìå®',
        description: errorMessage,
        variant: 'destructive',
      });

      // Ïã§Ìå® ÏãúÏóêÎèÑ Ï§ëÎã® ÌîåÎûòÍ∑∏ Ï†úÍ±∞ (Ïû¨ÏãúÎèÑ Í∞ÄÎä•ÌïòÎèÑÎ°ù)
      try {
        localStorage.removeItem(IN_PROGRESS_KEY);
        logger.info('Îß§Ïπ≠ ÏûëÏóÖ Ïã§Ìå®, ÌîåÎûòÍ∑∏ Ï†úÍ±∞', { submissionDate });
      } catch (storageError) {
        logger.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÌîåÎûòÍ∑∏ Ï†úÍ±∞ Ïã§Ìå®', storageError);
      }
    } finally {
      setIsProcessing(false);
    }
  };

  // 2Îã®Í≥Ñ: Îß§Ïπ≠ Í≤∞Í≥º ÏµúÏ¢Ö ÌôïÏù∏ Î∞è Ï†ÄÏû•
  const handleConfirmMatching = async () => {
    if (!cohortId || !sessionToken || !previewResult) return;

    setIsProcessing(true);
    setError(null);

    try {
      const response = await fetch('/api/admin/matching/confirm', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${sessionToken}`,
        },
        body: JSON.stringify({
          cohortId,
          matching: previewResult.matching,
          date: previewResult.date,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || data.error || 'Îß§Ïπ≠ Ï†ÄÏû• Ïã§Ìå®');
      }

      // ÌîÑÎ¶¨Î∑∞ Í≤∞Í≥ºÎ•º ÌôïÏù∏Îêú Í≤∞Í≥ºÎ°ú Ïù¥Îèô
      setConfirmedResult(previewResult);
      setPreviewResult(null);
      setMatchingState('confirmed');

      // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ (ÌîÑÎ¶¨Î∑∞ ÏÇ≠Ï†ú, ÌôïÏ†ï Ï†ÄÏû•)
      try {
        localStorage.removeItem(PREVIEW_STORAGE_KEY); // ÌîÑÎ¶¨Î∑∞Îäî ÏÇ≠Ï†ú
        localStorage.setItem(CONFIRMED_STORAGE_KEY, JSON.stringify(previewResult)); // ÌôïÏ†ï Í≤∞Í≥º Ï†ÄÏû•
        logger.info('ÌôïÏ†ï Í≤∞Í≥º Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû• ÏôÑÎ£å', { submissionDate });
      } catch (storageError) {
        logger.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû• Ïã§Ìå®', storageError);
      }

      // Firestore matching_previews ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (ÏûêÎèô ÏÉùÏÑ±Îêú previewÍ∞Ä ÏûàÎã§Î©¥)
      try {
        const { getDb } = await import('@/lib/firebase');
        const { collection, query, where, getDocs, updateDoc } = await import('firebase/firestore');

        const db = getDb();
        const previewsRef = collection(db, 'matching_previews');
        const q = query(
          previewsRef,
          where('cohortId', '==', cohortId),
          where('status', '==', 'pending')
        );

        const snapshot = await getDocs(q);

        if (!snapshot.empty) {
          // pending ÏÉÅÌÉúÏùò previewÎ•º confirmedÎ°ú Î≥ÄÍ≤Ω
          const updatePromises = snapshot.docs.map(doc =>
            updateDoc(doc.ref, { status: 'confirmed' })
          );
          await Promise.all(updatePromises);
          logger.info('Firestore matching_previews ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å', {
            count: snapshot.size,
            date: submissionDate
          });
        }
      } catch (firestoreError) {
        // Firestore ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®Îäî Î°úÍ∑∏Îßå ÎÇ®Í∏∞Í≥† Í≥ÑÏÜç ÏßÑÌñâ
        logger.error('Firestore matching_previews ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®', firestoreError);
      }

      toast({
        title: 'Îß§Ïπ≠ Ï†ÅÏö© ÏôÑÎ£å',
        description: 'Ïò§ÎäòÏùò ÏÑúÏû¨ÏóêÏÑú Ï∞∏Í∞ÄÏûêÎì§Ïù¥ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.',
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Îß§Ïπ≠ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
      setError(errorMessage);
      toast({
        title: 'Ï†ÄÏû• Ïã§Ìå®',
        description: errorMessage,
        variant: 'destructive',
      });
    } finally {
      setIsProcessing(false);
    }
  };

  // Î°úÎî© Ï§ë
  if (sessionLoading) {
    return (
      <PageTransition>
        <div className="app-shell flex flex-col overflow-hidden">
          <HeaderNavigation title="Îß§Ïπ≠ Í¥ÄÎ¶¨" />
          <main className="flex-1 flex items-center justify-center bg-background">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
          </main>
        </div>
      </PageTransition>
    );
  }

  // Í∂åÌïú ÏóÜÏùå
  if ((!currentUser?.isAdmin && !currentUser?.isAdministrator) || !cohortId) {
    return null;
  }

  const canMatch = yesterdayCount >= MATCHING_CONFIG.MIN_SUBMISSIONS_FOR_MATCHING;

  return (
    <PageTransition>
      <div className="app-shell flex flex-col overflow-hidden">
        <HeaderNavigation
          title="AI Îß§Ïπ≠ Í¥ÄÎ¶¨"
          showBackButton
          onBackClick={() => router.push(`/app/chat?cohort=${cohortId}`)}
        />

        <main className="flex-1 overflow-y-auto bg-admin-bg-page">
          <div className="mx-auto max-w-md px-4 py-6 space-y-4">
            {/* 1. Ïò§ÎäòÏùò Ïù∏Ï¶ù ÌòÑÌô© */}
            <div className={CARD_STYLES.CONTAINER}>
              <div className={CARD_STYLES.HEADER}>
                <h3 className="font-bold text-admin-text-primary">Ïò§ÎäòÏùò Ïù∏Ï¶ù ÌòÑÌô©</h3>
                <p className="text-xs text-admin-text-secondary mt-1">{todayDate}</p>
              </div>
              <div className={CARD_STYLES.BODY}>
                <div className="flex items-center justify-between">
                  <span className="text-sm text-admin-text-tertiary">Ï†úÏ∂ú ÏôÑÎ£å</span>
                  <span className="text-2xl font-bold text-admin-brand">
                    {isLoadingToday ? '...' : `${todayCount}Î™Ö`}
                  </span>
                </div>
                <p className="text-xs text-admin-text-secondary mt-2">ÎÇ¥Ïùº Îß§Ïπ≠ ÏòàÏ†ï</p>
              </div>
            </div>

            {/* 2. Ïñ¥Ï†ú Ïù∏Ï¶ù + Îß§Ïπ≠ÌïòÍ∏∞ */}
            <div className={CARD_STYLES.CONTAINER}>
              <div className={CARD_STYLES.HEADER}>
                <div className="flex items-center justify-between">
                  <div>
                    <h3 className="font-bold text-admin-text-primary">ÌîÑÎ°úÌïÑ Î∂Å Ï†ÑÎã¨ ÎåÄÏÉÅ</h3>
                    <p className="text-xs text-admin-text-secondary mt-1">{submissionDate}</p>
                    <p className="text-xs text-admin-text-secondary mt-2">Ïñ¥Ï†ú Ïù∏Ï¶ù ÏôÑÎ£å</p>
                  </div>
                  <div className="text-right">
                    <p className="text-2xl font-bold text-admin-brand">
                      {isLoadingYesterday ? '...' : `${yesterdayCount}Î™Ö`}
                    </p>
                    <div className="mt-1">
                      {matchingState === 'confirmed' ? (
                        <span className="inline-flex items-center gap-1 text-xs font-semibold text-admin-brand-success">
                          <Check className="h-3 w-3" />
                          Ï†ÑÎã¨ ÏôÑÎ£å
                        </span>
                      ) : matchingState === 'previewing' ? (
                        <span className="inline-flex items-center gap-1 text-xs font-semibold text-admin-brand-warning">
                          <Loader2 className="h-3 w-3" />
                          ÌôïÏù∏ ÎåÄÍ∏∞Ï§ë
                        </span>
                      ) : canMatch ? (
                        <span className="inline-flex items-center gap-1 text-xs font-semibold text-admin-brand">
                          <Check className="h-3 w-3" />
                          Îß§Ïπ≠ Í∞ÄÎä•
                        </span>
                      ) : (
                        <span className="inline-flex items-center gap-1 text-xs font-semibold text-admin-text-secondary">
                          <X className="h-3 w-3" />
                          Î∂àÍ∞ÄÎä•
                        </span>
                      )}
                    </div>
                  </div>
                </div>
              </div>
              <div className={CARD_STYLES.BODY}>
                {matchingState === 'idle' && (
                  <UnifiedButton
                    variant="primary"
                    onClick={handleStartMatching}
                    disabled={!canMatch || isProcessing}
                    icon={
                      isProcessing ? (
                        <Loader2 className="h-5 w-5 animate-spin" />
                      ) : undefined
                    }
                    className="w-full"
                  >
                    {isProcessing ? 'AI Î∂ÑÏÑù Ï§ë...' : 'Îß§Ïπ≠ ÏãúÏûëÌïòÍ∏∞'}
                  </UnifiedButton>
                )}

                {matchingState === 'previewing' && (
                  <div className="space-y-2">
                    <UnifiedButton
                      variant="primary"
                      fullWidth
                      onClick={handleConfirmMatching}
                      disabled={isProcessing}
                      icon={
                        isProcessing ? (
                          <Loader2 className="h-5 w-5 animate-spin" />
                        ) : (
                          <Check className="h-5 w-5" />
                        )
                      }
                    >
                      {isProcessing ? 'Ï†ÄÏû• Ï§ë...' : 'ÏµúÏ¢Ö ÌôïÏù∏ Î∞è Ï†ÅÏö©'}
                    </UnifiedButton>
                    <UnifiedButton
                      variant="outline"
                      fullWidth
                      onClick={handleStartMatching}
                      disabled={!canMatch || isProcessing}
                      icon={
                        isProcessing ? (
                          <Loader2 className="h-5 w-5 animate-spin" />
                        ) : undefined
                      }
                    >
                      {isProcessing ? 'AI Î∂ÑÏÑù Ï§ë...' : 'Îã§Ïãú Îß§Ïπ≠ÌïòÍ∏∞'}
                    </UnifiedButton>
                  </div>
                )}
              </div>
            </div>

            {/* ÏóêÎü¨ Î©îÏãúÏßÄ */}
            {error && (
              <div className="rounded-xl p-4 border bg-admin-bg-warning border-admin-border-warning">
                <p className="text-sm text-admin-text-tertiary">{error}</p>
              </div>
            )}

            {/* 3. ÌîÑÎ°úÌïÑÎ∂Å ÌòÑÌô© (Ìï≠ÏÉÅ ÌëúÏãú) */}
            <ParticipantAssignmentTable
              assignmentRows={assignmentRows}
              participantsLoading={participantsLoading}
              onOpenProfile={handleOpenProfile}
              matchingState={matchingState}
            />

            {/* ÏïàÎÇ¥ Î©îÏãúÏßÄ */}
            <div className="rounded-xl p-4 border bg-admin-bg-info border-admin-border">
              <p className="text-xs leading-relaxed text-admin-text-tertiary">
                <strong className="text-admin-text-primary">Îß§Ïπ≠ Ïö¥ÏòÅ Í∞ÄÏù¥Îìú</strong>
                <br />‚Ä¢ ÏµúÏÜå 4Î™ÖÏùò Ï∞∏Í∞ÄÏûêÍ∞Ä Ïò§ÎäòÏùò ÏßàÎ¨∏Ïóê ÎãµÎ≥ÄÌï¥Ïïº AI Îß§Ïπ≠ÏùÑ Ïã§ÌñâÌï† Ïàò ÏûàÏäµÎãàÎã§.
                <br />‚Ä¢ AIÎäî Ï∞∏Í∞ÄÏûêÎì§Ïùò ÎãµÎ≥ÄÏùÑ Î∂ÑÏÑùÌï¥ Ïò§Îäò Í≥µÍ∞úÌï† ÌîÑÎ°úÌïÑÎ∂Å 4Í∞ú(Ïú†ÏÇ¨ 2, Î∞òÎåÄ 2)Î•º ÏÑ†Ï†ïÌï©ÎãàÎã§.
                <br />‚Ä¢ ÏÑ†Ï†ïÎêú ÌîÑÎ°úÌïÑÎ∂ÅÏùÄ Ïò§ÎäòÏùò ÏÑúÏû¨Ïóê ÏûêÎèô Í≤åÏãúÎêòÎ©∞, ÌïÑÏöî Ïãú Ïù¥ ÌéòÏù¥ÏßÄÏóêÏÑú Ïû¨Îß§Ïπ≠Ìï† Ïàò ÏûàÏäµÎãàÎã§.
              </p>
            </div>
          </div>
        </main>
      </div>
    </PageTransition>
  );
}

export default function MatchingPage() {
  return (
    <Suspense
      fallback={
        <div className="app-shell flex items-center justify-center bg-[#eff6ff]">
          <Loader2 className="h-8 w-8 animate-spin text-[#45a1fd]" />
        </div>
      }
    >
      <MatchingPageContent />
    </Suspense>
  );
}
